"""  coded by Dvoretsky Vasily
     mail:  vasya.dvoretsky@yandex.ru
     
"""
"""  coded by Dvoretsky Vasily
     mail:  vasya.dvoretsky@yandex.ru
     
"""
"""importing required libraries """
import cv2           #library of computer vision
import numpy as np   #library of math
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
#import matplotlib.tri as tri
import matplotlib


"""importing the image"""
img = cv2.imread('circles0.jpg',3)
#img = cv2.imread("1.jpg",3)


"""drawing a circle of certain size """
cv2.circle(img, (22,22),21, (200,200,80), -1)           
"""converting of the image into grayscale """
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
#cv2.imshow('circles', gray )                       

     
"""Applying Hough algorithm to the image"""
circles = cv2.HoughCircles(gray, cv2.HOUGH_GRADIENT, 1,33,param1=2,param2=15,minRadius=20,maxRadius=29)

print( circles)

circles_save = circles
"""A bit of  information for people without without telepathic abilities  XD
#   circles is a three-dimensional array of ([[[x1, y1,r1]
                                               [x2, y2,r2]
                                               ..........
                                               [xn,yn,rn]]])
#   it can be represented as              ([[[i[0][ 0 ][0],i[0][ 0 ][1],i[0][ 0 ][2]]
                                             [i[0][ 1 ][0],i[0][ 1 ][1],i[0][ 1 ][2]]
                                              ........................................
                                             [i[0][n-1][0],i[0][n-1][1],i[0][n-1][2]]]])
#   
#            n is a number of found by hough algorithm circles
#       to decreaze the dimensions of an array i use ...
#       array = array[0]
#       it converts the array into         ([[[i[ 0 ][0],i[ 0 ][1],i[ 0 ][2]]
                                              [i[ 1 ][0],i[ 1 ][1],i[ 1 ][2]]
                                              ........................................
                                              [i[n-1][0],i[n-1][1],i[n-1][2]]]])
#        thus shortening the length of the request 
#


"""

for i in circles[0,:]:
    
    cv2.circle(img,(i[0],i[1]),i[2],(0,255,0),2)
    cv2.circle(img,(i[0],i[1]),2,(0,0,255),3)
   

cv2.imshow('circles1', img)

original_array = circles
or_a = original_array[0]


def Lenght(i,datatype):     #datatype = int or float
    
    new_arrayLenght = np.empty([np.int_(np.shape(original_array)[1]*(np.shape(original_array)[1]-1)/2), 1],dtype=datatype)  # НО МОЖНО И float
    k=0
    for i in range(np.shape(original_array)[1]-1):
        for j in range(1,np.shape(original_array)[1]):
            if j<i or j==i:
#                print("пропускаем",i,j)
                j=j+1
            else:
#            print("берём",i,j)
                new_arrayLenght[k] = np.sqrt((or_a[i][0]- or_a[j][0])**2 + (or_a[i][1]- or_a[j][1])**2 )
#                print("берём",i,j,new_array[i])
                k=k+1
                j=j+1
        continue
    return  new_arrayLenght


def Alfa(i,datatype):    #datatype = int or float
    new_arrayAlfa = np.empty([np.int_(np.shape(original_array)[1]*(np.shape(original_array)[1]-1)/2), 1],dtype=datatype)  # НО МОЖНО И float
    k1=0
    for i in range(np.shape(original_array)[1]-1):
        for j in range(1,np.shape(original_array)[1]):
            if j<i or j==i:
#                print("пропускаем",i,j)
                j=j+1
            else:
#            print("берём",i,j)
                new_arrayAlfa[k1] = np.rad2deg(np.arctan((or_a[i][1]- or_a[j][1])/(or_a[i][0]- or_a[j][0])))
#                print("берём",i,j,new_array[i])
                k1=k1+1
                j=j+1
        continue
    return  new_arrayAlfa

#___________________________________________________________________________________
def Betta(i,datatype):   #datatype = int or float
    new_arrayBetta = np.empty([np.int_(np.shape(original_array)[1]*(np.shape(original_array)[1]-1)/2), 1],dtype=datatype)  # НО МОЖНО И float
    k2=0
    for i in range(np.shape(original_array)[1]-1):
        for j in range(1,np.shape(original_array)[1]):
            if j<i or j==i:
#                print("пропускаем",i,j)
                j=j+1
            else:
#            print("берём",i,j)
                new_arrayBetta[k2] = or_a[i][1]+ ((or_a[i][1]- or_a[j][1])/(or_a[i][0]- or_a[j][0]))*or_a[i][0] 
#                print("берём",i,j,new_array[i])
                k2=k2+1
                j=j+1
        continue
    return  new_arrayBetta
   
#    
#print(Betta(or_a,float))
#print()
#print(Alfa(or_a,float))
#print()
#print(Lenght(or_a,float))

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

xs=[Lenght(or_a,float)]
ys=[Alfa(or_a,float)]
zs=[Betta(or_a,float)]


ax.scatter(xs, ys, zs, c='r', marker='o')
#ax.scatter(xt, yt, zt, c='b', marker='^')

ax.set_xlabel('Длинна вектора (Length)')
ax.set_ylabel('Угол наклона (Alfa)')
ax.set_zlabel('Приращение (Betta)')

plt.show()




k = cv2.waitKey(0)
if k == 27:
    cv2.destroyAllWindows()
